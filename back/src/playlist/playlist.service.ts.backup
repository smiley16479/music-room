import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  ConflictException,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindOptionsWhere, In, IsNull } from 'typeorm';

import {
  Playlist
} from 'src/playlist/entities/playlist.entity';
import { PlaylistTrack } from 'src/playlist/entities/playlist-track.entity';
import { Track } from 'src/music/entities/track.entity';
import { User } from 'src/user/entities/user.entity';
import { Event, EventVisibility } from 'src/event/entities/event.entity';
import {
  Invitation,
  InvitationType,
  InvitationStatus
} from 'src/invitation/entities/invitation.entity';

import { CreatePlaylistDto } from './dto/create-playlist.dto';
import { UpdatePlaylistDto } from './dto/update-playlist.dto';
import { AddTrackToPlaylistDto } from './dto/add-track.dto';
import { ReorderTracksDto } from './dto/reorder-tracks.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

import { EventService } from '../event/event.service';
import { MusicService } from '../music/music.service';
import { DeezerTrack } from '../music/interfaces/deezer.interface';
import { EmailService } from '../email/email.service';
import { EventGateway } from '../event/event.gateway';
import { ParticipantRole, EventParticipant } from 'src/event/entities/event-participant.entity';
import { EventParticipantService } from '../event/event-participant.service';
import { EventType } from 'src/event/entities/event-type.enum';

export interface PlaylistWithStats extends Playlist {
  stats: {
    trackCount: number;
    totalDuration: number;
    collaboratorCount: number;
    isUserCollaborator: boolean;
    isUserOwner: boolean;
  };
}

export interface PlaylistTrackWithDetails extends PlaylistTrack {
  track: Track;
  addedBy: User;
}

export interface CollaborativeOperation {
  type: 'add' | 'remove' | 'reorder' | 'update';
  trackId?: string;
  position?: number;
  userId: string;
  timestamp: Date;
}

@Injectable()
export class PlaylistService {
  constructor(
    @InjectRepository(Playlist)
    private playlistRepository: Repository<Playlist>,
    @InjectRepository(PlaylistTrack)
    private playlistTrackRepository: Repository<PlaylistTrack>,
    @InjectRepository(Track)
    private trackRepository: Repository<Track>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Event)
    private eventRepository: Repository<Event>,
    @InjectRepository(Invitation)
    private invitationRepository: Repository<Invitation>,
    private musicService: MusicService,
    private emailService: EmailService,
    @Inject(forwardRef(() => EventService))
    private eventService: EventService,
    private eventParticipantService: EventParticipantService,
    @Inject(forwardRef(() => EventGateway))
    private eventGateway: EventGateway,
  ) {}

  // CRUD Operations
  async create(createPlaylistDto: CreatePlaylistDto, creatorId: string): Promise<PlaylistWithStats> {
    const creator = await this.userRepository.findOne({ where: { id: creatorId } });
    if (!creator) {
      throw new NotFoundException('Creator not found');
    }

    // Create an Event for the playlist first (LISTENING_SESSION by default)
    const event = this.eventRepository.create({
      name: createPlaylistDto.name,
      description: createPlaylistDto.description || 'Playlist listening session',
      coverImageUrl: createPlaylistDto.coverImageUrl,
      creatorId,
      type: EventType.LISTENING_SESSION,
      visibility: EventVisibility.PRIVATE, // Default to private
      votingEnabled: false,
    });

    const savedEvent = await this.eventRepository.save(event);

    // Add creator as participant with CREATOR role
    await this.eventParticipantService.addParticipant(savedEvent.id, creatorId, ParticipantRole.CREATOR);

    // Create the playlist linked to the event (only contains playback stats now)
    const playlist = this.playlistRepository.create({
      eventId: savedEvent.id,
      trackCount: 0,
      totalDuration: 0,
    });

    const savedPlaylist = await this.playlistRepository.save(playlist);

    // Update the event with the playlist relationship
    savedEvent.playlist = savedPlaylist;
    await this.eventRepository.save(savedEvent);

    // Attach event to playlist for gateway notification
    savedPlaylist.event = savedEvent;

    // Notify about playlist creation
    this.eventGateway.notifyPlaylistCreated(savedPlaylist, creator);

    return this.findById(savedPlaylist.id, creatorId);
  }

  async findAll(paginationDto: PaginationDto, userId?: string, isPublic?: boolean, ownerId?: string) {
    const { page, limit, skip } = paginationDto;

    const queryBuilder = this.playlistRepository.createQueryBuilder('playlist')
      .leftJoinAndSelect('playlist.event', 'event')
      .leftJoinAndSelect('event.creator', 'creator');

    // Apply filters based on parameters
    if (isPublic !== undefined) {
      // Filter by visibility (public/private)
      const visibility = isPublic ? EventVisibility.PUBLIC : EventVisibility.PRIVATE;
      
      queryBuilder.andWhere('event.visibility = :visibility', { visibility });
      
      if (!isPublic && userId) {
        // For private playlists, check if user has access via event participants
        queryBuilder
          .leftJoin('event.participants', 'participant')
          .andWhere(
            '(event.creatorId = :userId OR participant.userId = :userId)',
            { userId }
          );
      } else if (!isPublic) {
        // No user authenticated - no private playlists visible
        queryBuilder.where('1 = 0'); // Return no results
      }
    } else if (ownerId) {
      // Filter by specific owner
      if (ownerId === userId) {
        // Get playlists the user owns or participates in
        queryBuilder
          .leftJoin('event.participants', 'participant')
          .where(
            '(event.creatorId = :ownerId OR participant.userId = :userId)',
            { ownerId, userId }
          );
      } else {
        // Filter by specific owner only
        queryBuilder.where('event.creatorId = :ownerId', { ownerId });
      }
    } else {
      // Default behavior: show public playlists + private playlists user has access to
      if (userId) {
        queryBuilder
          .leftJoin('event.participants', 'participant')
          .where(
            '(event.visibility = :publicVisibility OR (event.visibility = :privateVisibility AND (event.creatorId = :userId OR participant.userId = :userId)))',
            { publicVisibility: EventVisibility.PUBLIC, privateVisibility: EventVisibility.PRIVATE, userId }
          );
      } else {
        // No user authenticated - only show public playlists
        queryBuilder.where('event.visibility = :visibility', { visibility: EventVisibility.PUBLIC });
      }
    }

    queryBuilder
      .orderBy('playlist.updatedAt', 'DESC')
      .skip(skip)
      .take(limit);

    const [playlists, total] = await queryBuilder.getManyAndCount();

    const playlistsWithStats = await Promise.all(
      playlists.map(playlist => this.addPlaylistStats(playlist, userId)),
    );

    const totalPages = Math.ceil(total / limit);

    return {
      success: true,
      data: playlistsWithStats,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      },
      timestamp: new Date().toISOString(),
    };
  }

  async findById(id: string, userId?: string): Promise<PlaylistWithStats> {
    const playlist = await this.playlistRepository.findOne({
      where: { id },
      relations: ['event'],
    });

    if (!playlist) {
      throw new NotFoundException('Playlist not found');
    }

    // Check access permissions
    await this.checkPlaylistAccess(playlist, userId);

    return this.addPlaylistStats(playlist, userId);
  }

  async update(
    id: string,
    updatePlaylistDto: UpdatePlaylistDto,
    userId: string
  ): Promise<PlaylistWithStats> {
    const playlist = await this.playlistRepository.findOne({
      where: { id },
      relations: ['event'],
    });

    if (!playlist) {
      throw new NotFoundException('Playlist not found');
    }

    // Check if user can edit
    await this.checkEditPermissions(playlist, userId);

    // Update the Event metadata (name, description, coverImageUrl)
    if (playlist.event) {
      Object.assign(playlist.event, updatePlaylistDto);
      await this.eventRepository.save(playlist.event);
    }

    // Reload the playlist with all relations to ensure we have fresh data
    const updatedPlaylist = await this.playlistRepository.findOne({
      where: { id },
      relations: ['event'],
    });

    if (!updatedPlaylist) {
      throw new NotFoundException('Playlist not found after update');
    }

    // Notify collaborators of changes
    this.eventGateway.notifyPlaylistUpdated(id, updatedPlaylist, userId);

    return this.addPlaylistStats(updatedPlaylist, userId);
  }

  async remove(id: string, userId: string): Promise<void> {
    const playlist = await this.playlistRepository.findOne({
      where: { id },
      relations: ['event'],
    });

    if (!playlist) {
      throw new NotFoundException('Playlist not found');
    }

    // Only creator can delete playlist (creator is managed via event)
    const event = await this.eventRepository.findOne({ where: { id: playlist.eventId } });
    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    if (event.creatorId !== userId) {
      throw new ForbiddenException('Only the creator can delete this playlist');
    }

    await this.playlistRepository.remove(playlist);

    // Notify collaborators
    this.eventGateway.notifyPlaylistDeleted(id, userId);
  }

  // Track Management
  async addTrack(
    playlistId: string,
    userId: string,
    addTrackDto: AddTrackToPlaylistDto
  ): Promise<PlaylistTrackWithDetails> {
    const playlist = await this.findById(playlistId, userId);

    console.log(`Adding track to playlist ${playlistId} by user ${userId}`, playlist, '\n', addTrackDto);
    
    // Check edit permissions
    await this.checkEditPermissions(playlist, userId);

    // Validate required fields
    if (!addTrackDto.deezerId) {
      throw new BadRequestException('Deezer ID is required');
    }

    if (!userId) {
      throw new BadRequestException('User ID is required');
    }

    if (!playlistId) {
      throw new BadRequestException('Playlist ID is required');
    }

    // Get or create track using music service to ensure YouTube search is performed
    let track = await this.trackRepository.findOne({
      where: { deezerId: addTrackDto.deezerId },
    });

    if (!track) {
      // Use music service to create track with YouTube search
      console.log(`ðŸŽµ Creating new track with YouTube search for: "${addTrackDto.title}" by ${addTrackDto.artist}`);
      const deezerTrack: DeezerTrack = {
        id: addTrackDto.deezerId,
        title: addTrackDto.title,
        title_short: addTrackDto.title,
        title_version: '',
        link: '',
        duration: addTrackDto.duration || 0,
        rank: 0,
        explicit_lyrics: false,
        explicit_content_lyrics: 0,
        explicit_content_cover: 0,
        preview: addTrackDto.previewUrl || '',
        md5_image: '',
        artist: {
          id: '0',
          name: addTrackDto.artist,
          link: '',
          picture: '',
          picture_small: '',
          picture_medium: '',
          picture_big: '',
          picture_xl: '',
          tracklist: '',
          type: 'artist'
        },
        album: {
          id: '0',
          title: addTrackDto.album,
          cover: addTrackDto.albumCoverUrl || '',
          cover_small: addTrackDto.albumCoverUrl || '',
          cover_medium: addTrackDto.albumCoverUrl || '',
          cover_big: addTrackDto.albumCoverUrl || '',
          cover_xl: addTrackDto.albumCoverUrl || '',
          md5_image: '',
          release_date: '',
          tracklist: '',
          type: 'album'
        },
        type: 'track'
      };
      
      track = await this.musicService.getOrCreateTrackFromDeezer(deezerTrack);
      console.log(`ðŸŽµ Track created with Deezer preview: ${track.title}, previewUrl: ${track.previewUrl}`);
    }

    if (!track) {
      throw new BadRequestException('Failed to create or retrieve track');
    }

    // Check if track already exists in playlist
    const existingTrack = await this.playlistTrackRepository.findOne({
      where: { playlistId, trackId: track.id },
    });

    if (existingTrack) {
      throw new ConflictException('Track already exists in playlist');
    }

    // Determine position
    let position = addTrackDto.position;
    if (!position) {
      const lastTrack = await this.playlistTrackRepository.findOne({
        where: { playlistId },
        order: { position: 'DESC' },
      });
      position = (lastTrack?.position || 0) + 1;
    } else {
      // Shift existing tracks if inserting at specific position
      await this.shiftTracksPosition(playlistId, position, 1);
    }

    // Create playlist track with validation
    const playlistTrack = this.playlistTrackRepository.create({
      playlistId,
      trackId: track.id,
      addedById: userId,
      position,
    });

    // Validate required fields before saving
    if (!playlistTrack.playlistId || !playlistTrack.trackId || !playlistTrack.addedById) {
      throw new BadRequestException('Missing required fields for playlist track');
    }

    const savedPlaylistTrack = await this.playlistTrackRepository.save(playlistTrack);

    // Update playlist stats
    await this.updatePlaylistStats(playlistId);

    // Get complete track details
    const trackWithDetails = await this.playlistTrackRepository.findOne({
      where: { id: savedPlaylistTrack.id },
      relations: ['track', 'addedBy'],
    }) as PlaylistTrackWithDetails;

    // Get updated track count
    const updatedPlaylist = await this.playlistRepository.findOne({
      where: { id: playlistId }
    });

    // Notify collaborators
    this.eventGateway.notifyTrackAdded(playlistId, trackWithDetails, userId, updatedPlaylist?.trackCount || 0);

    // If this playlist belongs to an event, also notify the event participants
    if (playlist.eventId) {
      this.eventGateway.notifyTrackAdded(playlist.eventId, trackWithDetails.track, userId);
    }

    return trackWithDetails;
  }

  async removeTrack(
    playlistId: string,
    trackId: string,
    userId: string
  ): Promise<void> {
    const playlist = await this.findById(playlistId, userId);

    // Check edit permissions
    await this.checkEditPermissions(playlist, userId);

    const playlistTrack = await this.playlistTrackRepository.findOne({
      where: { playlistId, trackId },
      relations: ['track', 'addedBy'],
    });

    if (!playlistTrack) {
      throw new NotFoundException('Track not found in playlist');
    }

    const position = playlistTrack.position;

    // Remove track
    await this.playlistTrackRepository.remove(playlistTrack);

    // Remove vote records associated with this track in the context of an event
    if (playlist.eventId) {
      await this.eventService.removeVotesOfTrack(playlist.eventId, trackId);
    }
  
    // Shift remaining tracks
    await this.shiftTracksPosition(playlistId, position + 1, -1);

    // Update playlist stats
    await this.updatePlaylistStats(playlistId);

    // Get updated track count
    const updatedPlaylist = await this.playlistRepository.findOne({
      where: { id: playlistId }
    });

    // Notify collaborators
    this.eventGateway.notifyTrackRemoved(playlistId, trackId, userId, updatedPlaylist?.trackCount || 0);

    // If this playlist belongs to an event, also notify the event participants
    if (playlist.eventId) {
      this.eventGateway.notifyTrackRemoved(playlist.eventId, trackId, userId);
    }
  }

  async reorderTracks(
    playlistId: string,
    userId: string,
    reorderDto: ReorderTracksDto
  ): Promise<PlaylistTrackWithDetails[]> {
    const playlist = await this.findById(playlistId, userId);

    // Check edit permissions
    await this.checkEditPermissions(playlist, userId);

    const { trackIds } = reorderDto;

    // Validate all tracks exist in playlist
    const existingTracks = await this.playlistTrackRepository.find({
      where: { playlistId, trackId: In(trackIds) },
    });

    if (existingTracks.length !== trackIds.length) {
      throw new BadRequestException('Some tracks are not in the playlist');
    }

    // Update positions
    for (let i = 0; i < trackIds.length; i++) {
      await this.playlistTrackRepository.update(
        { playlistId, trackId: trackIds[i] },
        { position: i + 1 },
      );
    }

    // Get updated tracks
    const updatedTracks = await this.getPlaylistTracks(playlistId);

    // Notify collaborators
    this.eventGateway.notifyTracksReordered(playlistId, trackIds, userId);

    return updatedTracks;
  }

  async getPlaylistTracks(playlistId: string, userId?: string): Promise<any[]> {
    const playlist = await this.findById(playlistId, userId);

    const tracks = await this.playlistTrackRepository.find({
      where: { playlistId },
      relations: ['track', 'addedBy', 'votes'],
      order: { position: 'ASC' },
    });

    const tracksWithVoteCounts = tracks.map(pt => {
      const likes = pt.votes?.filter(v => v.type === 'upvote').length || 0;
      const dislikes = pt.votes?.filter(v => v.type === 'downvote').length || 0;
      return {
        ...pt,
        track: {
          ...pt.track,
          likes,
          dislikes,
        },
      };
    });
    return tracksWithVoteCounts// as PlaylistTrackWithDetails[];
  }

  // Collaborator Management
  async addCollaborator(
    playlistId: string,
    collaboratorId: string,
    requesterId: string
  ): Promise<void> {
    console.log(`Adding collaborator ${collaboratorId} to playlist ${playlistId} by ${requesterId}`);
    const playlist = await this.findById(playlistId, requesterId);

    // Check if requester can add collaborators
    const event = await this.eventRepository.findOne({ where: { id: playlist.eventId } });
    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    const canEdit = await this.eventParticipantService.canEdit(event, requesterId);
    if (!canEdit) {
      throw new ForbiddenException('You cannot add collaborators to this playlist');
    }

    // Add collaborator via event participants
    await this.eventParticipantService.addCollaborator(event.id, collaboratorId);

    const collaborator = await this.userRepository.findOne({
      where: { id: collaboratorId }
    });

    // Notify collaborators
    this.eventGateway.notifyCollaboratorAdded(playlistId, collaborator!, requesterId);
  }

  async removeCollaborator(
    playlistId: string,
    collaboratorId: string,
    requesterId: string
  ): Promise<void> {
    const playlist = await this.findById(playlistId, requesterId);

    const event = await this.eventRepository.findOne({ where: { id: playlist.eventId } });
    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    // Creator can remove anyone, collaborators can only remove themselves
    const canRemove = event.creatorId === requesterId || (collaboratorId === requesterId);

    if (!canRemove) {
      throw new ForbiddenException('You cannot remove this collaborator');
    }

    // Cannot remove creator (creator is the event creator)
    if (collaboratorId === event.creatorId) {
      throw new BadRequestException('Cannot remove playlist creator');
    }

    // Remove collaborator via event participants
    await this.eventParticipantService.removeCollaborator(event.id, collaboratorId);

    const collaborator = await this.userRepository.findOne({
      where: { id: collaboratorId }
    });

    // Notify collaborators
    this.eventGateway.notifyCollaboratorRemoved(playlistId, collaborator!, requesterId);
  }

  async getCollaborators(playlistId: string, userId?: string): Promise<User[]> {
    const playlist = await this.playlistRepository.findOne({
      where: { id: playlistId },
    });

    if (!playlist) {
      throw new NotFoundException('Playlist not found');
    }

    await this.checkPlaylistAccess(playlist, userId);

    // Get collaborators from event participants
    const participants = await this.eventParticipantService.getCollaboratorsWithRole(playlist.eventId);
    return participants.map(p => p.user);
  }

  // Search and Discovery
  async searchPlaylists(query: string, userId?: string, limit = 20) {
    const queryBuilder = this.playlistRepository.createQueryBuilder('playlist')
      .leftJoinAndSelect('playlist.event', 'event')
      .leftJoinAndSelect('event.creator', 'creator')
      .where('event.visibility = :visibility', { visibility: EventVisibility.PUBLIC })
      .andWhere('playlist.eventId IS NULL') // Exclude event playlists
      .andWhere('(event.name LIKE :query OR event.description LIKE :query)')
      .setParameter('query', `%${query}%`)
      .orderBy('playlist.updatedAt', 'DESC')
      .take(limit);

    const playlists = await queryBuilder.getMany();

    const playlistsWithStats = await Promise.all(
      playlists.map(playlist => this.addPlaylistStats(playlist, userId)),
    );

    return {
      success: true,
      data: playlistsWithStats,
      timestamp: new Date().toISOString(),
    };
  }

  async getMyPlaylists(userId: string, paginationDto: PaginationDto): Promise<any> {
    // Get all playlists the user owns or has been invited to (all playlists are event-based now)
    return this.findAll(paginationDto, userId, undefined, userId);
  }

  async getRecommendedPlaylists(userId: string, limit = 20) {
    // Get user's music preferences
    const user = await this.userRepository.findOne({ where: { id: userId } });
    if (!user || !user.musicPreferences?.favoriteGenres) {
      return this.findAll({ page: 1, limit } as PaginationDto, userId);
    }

    // Find playlists with tracks matching user's preferences
    // This is a simplified version - in production you'd want more sophisticated recommendation logic
    const playlists = await this.playlistRepository
      .createQueryBuilder('playlist')
      .leftJoinAndSelect('playlist.creator', 'creator')
      .leftJoin('playlist.event', 'event')
      .where('event.visibility = :visibility', { visibility: EventVisibility.PUBLIC })
      .andWhere('playlist.eventId IS NULL') // Exclude event playlists
      .orderBy('playlist.updatedAt', 'DESC')
      .take(limit)
      .getMany();

    const playlistsWithStats = await Promise.all(
      playlists.map(playlist => this.addPlaylistStats(playlist, userId)),
    );

    return {
      success: true,
      data: playlistsWithStats,
      timestamp: new Date().toISOString(),
    };
  }

  // Playlist Duplication
  async duplicatePlaylist(
    originalPlaylistId: string,
    userId: string,
    newName?: string
  ): Promise<PlaylistWithStats> {
    const originalPlaylist = await this.findById(originalPlaylistId, userId);
    const originalTracks = await this.getPlaylistTracks(originalPlaylistId, userId);

    // Create new playlist (metadata comes from Event)
    const duplicatePlaylist = await this.create({
      name: newName || `Copy of ${originalPlaylist.event?.name || 'Playlist'}`,
      description: originalPlaylist.event?.description,
      coverImageUrl: originalPlaylist.event?.coverImageUrl,
    }, userId);

    // Copy all tracks
    for (const playlistTrack of originalTracks) {
      await this.addExistingTrackToPlaylist(
        duplicatePlaylist.id,
        playlistTrack.track.id,
        userId,
        playlistTrack.position
      );
    }

    return this.findById(duplicatePlaylist.id, userId);
  }

  // Invitation System
  async inviteCollaborators(
    playlistId: string,
    inviterUserId: string,
    inviteeIds: string[],
    message?: string,
  ): Promise<{ invitations: Invitation[]; skipped: { userId: string; reason: string }[] }> {
    const playlist = await this.playlistRepository.findOne({ where: { id: playlistId } });
    
    if (!playlist) {
      throw new NotFoundException('Playlist not found');
    }

    const event = await this.eventRepository.findOne({ where: { id: playlist.eventId } });
    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    // Check if inviter can invite
    const canInvite = await this.eventParticipantService.canEdit(event, inviterUserId);

    if (!canInvite) {
      throw new ForbiddenException('You cannot invite collaborators to this playlist');
    }

    const inviter = await this.userRepository.findOne({ where: { id: inviterUserId } });

    const createdInvitations: Invitation[] = [];
    const skipped: { userId: string; reason: string }[] = [];
    const uniqueInviteeIds = Array.from(new Set(inviteeIds));

    for (const inviteeId of uniqueInviteeIds) {
      if (inviteeId === inviterUserId) {
        skipped.push({ userId: inviteeId, reason: 'cannot_invite_self' });
        continue;
      }

      const invitee = await this.userRepository.findOne({ where: { id: inviteeId } });

      if (!invitee) {
        skipped.push({ userId: inviteeId, reason: 'user_not_found' });
        continue;
      }

      // Check if already collaborator via event participants
      const isAlreadyCollaborator = await this.eventParticipantService.isUserCollaborator(event.id, inviteeId);
      if (event.creatorId === inviteeId || isAlreadyCollaborator) {
        skipped.push({ userId: inviteeId, reason: 'already_collaborator' });
        continue;
      }

      const existingInvitation = await this.invitationRepository.findOne({
        where: {
          eventId: event.id,
          inviteeId,
        },
        order: { createdAt: 'DESC' },
      });

      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

      if (existingInvitation && existingInvitation.status === InvitationStatus.PENDING) {
        skipped.push({ userId: inviteeId, reason: 'already_invited' });
        continue;
      }

      let savedInvitation: Invitation;

      if (existingInvitation) {
        existingInvitation.status = InvitationStatus.PENDING;
        existingInvitation.message = message;
        existingInvitation.inviterId = inviterUserId;
        existingInvitation.expiresAt = expiresAt;
        savedInvitation = await this.invitationRepository.save(existingInvitation);
      } else {
        const invitation = this.invitationRepository.create({
          inviterId: inviterUserId,
          inviteeId,
          eventId: event.id,
          status: InvitationStatus.PENDING,
          message,
          expiresAt,
        });

        savedInvitation = await this.invitationRepository.save(invitation);
      }

      createdInvitations.push(savedInvitation);

      if (invitee.email) {
        const baseUrl = process.env.FRONTEND_URL || 'https://music-room.com';
        const playlistUrl = `${baseUrl}/playlists/${playlistId}`;
        await this.emailService.sendPlaylistInvitation(
          invitee.email,
          event.name,
          inviter?.displayName || 'A friend',
          playlistUrl,
        );
      }
    }

    return { invitations: createdInvitations, skipped };
  }

  // Export/Import
  async exportPlaylist(playlistId: string, userId: string): Promise<any> {
    const playlist = await this.findById(playlistId, userId);
    const tracks = await this.getPlaylistTracks(playlistId, userId);

    return {
      playlist: {
        name: playlist.event?.name || 'Unnamed Playlist',
        description: playlist.event?.description,
        coverImageUrl: playlist.event?.coverImageUrl,
        createdAt: playlist.createdAt,
        updatedAt: playlist.updatedAt,
      },
      tracks: tracks.map(pt => ({
        position: pt.position,
        addedAt: pt.addedAt,
        track: {
          deezerId: pt.track.deezerId,
          title: pt.track.title,
          artist: pt.track.artist,
          album: pt.track.album,
          duration: pt.track.duration,
        },
      })),
    };
  }

  // Helper Methods
  private async addPlaylistStats(
    playlist: Playlist,
    userId?: string
  ): Promise<PlaylistWithStats> {
    // Get collaborator count from event participants
    const collaboratorCount = await this.eventParticipantService.getCollaboratorCount(playlist.eventId);
    
    const isUserCollaborator = userId ?
      await this.eventParticipantService.isUserCollaborator(playlist.eventId, userId) : false;
    
    // Check if user is owner via event creator
    let isUserOwner = false;
    if (userId) {
      const event = await this.eventRepository.findOne({ where: { id: playlist.eventId } });
      isUserOwner = event ? event.creatorId === userId : false;
    }

    return {
      ...playlist,
      stats: {
        trackCount: playlist.trackCount,
        totalDuration: playlist.totalDuration,
        collaboratorCount,
        isUserCollaborator,
        isUserOwner,
      },
    };
  }

  private async checkPlaylistAccess(playlist: Playlist, userId?: string): Promise<void> {
    // Load the event to check visibility
    const event = await this.eventRepository.findOne({
      where: { id: playlist.eventId },
    });

    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    if (event.visibility === EventVisibility.PUBLIC) {
      return; // Public playlists are accessible to everyone
    }

    if (!userId) {
      throw new ForbiddenException('Authentication required for private playlists');
    }

    // For private playlists: check if user is creator or participant
    const isCreator = event.creatorId === userId;
    
    if (isCreator) {
      return; // Creator has access
    }

    // Check if user is a participant
    const isParticipant = await this.eventParticipantService.isUserParticipant(event.id, userId);

    if (!isParticipant) {
      throw new ForbiddenException('You do not have access to this private playlist');
    }
  }

  private async checkEditPermissions(playlist: Playlist, userId: string): Promise<void> {
    // Load the event to check permissions
    const event = await this.eventRepository.findOne({
      where: { id: playlist.eventId },
    });

    if (!event) {
      throw new NotFoundException('Associated event not found');
    }

    // Check if user is creator or collaborator
    const canEdit = await this.eventParticipantService.canEdit(event, userId);

    if (!canEdit) {
      throw new ForbiddenException('You do not have permission to edit this playlist');
    }
  }

  private async shiftTracksPosition(
    playlistId: string,
    fromPosition: number,
    shift: number
  ): Promise<void> {
    if (shift > 0) {
      // Shifting up - update in descending order to avoid constraint violations
      await this.playlistTrackRepository
        .createQueryBuilder()
        .update(PlaylistTrack)
        .set({ position: () => 'position + :shift' })
        .where('playlistId = :playlistId AND position >= :fromPosition')
        .setParameters({ playlistId, fromPosition, shift })
        .execute();
    } else {
      // Shifting down - update in ascending order
      await this.playlistTrackRepository
        .createQueryBuilder()
        .update(PlaylistTrack)
        .set({ position: () => 'position + :shift' })
        .where('playlistId = :playlistId AND position >= :fromPosition')
        .setParameters({ playlistId, fromPosition, shift })
        .execute();
    }
  }

  private async updatePlaylistStats(playlistId: string): Promise<void> {
    const tracks = await this.playlistTrackRepository.find({
      where: { playlistId },
      relations: ['track'],
    });

    const trackCount = tracks.length;
    const totalDuration = tracks.reduce((sum, pt) => sum + (pt.track?.duration || 0), 0);

    await this.playlistRepository.update(playlistId, {
      trackCount,
      totalDuration,
      updatedAt: new Date(),
    });
  }

  // Ajout d'un track existant Ã  une playlist (pour duplication)
  private async addExistingTrackToPlaylist(
    playlistId: string,
    trackId: string,
    userId: string,
    position?: number
  ) {
    // VÃ©rifie que le track existe en base
    const track = await this.trackRepository.findOne({ where: { id: trackId } });
    if (!track) throw new NotFoundException('Track not found');

    // VÃ©rifie qu'il n'est pas dÃ©jÃ  dans la playlist
    const existingTrack = await this.playlistTrackRepository.findOne({ where: { playlistId, trackId } });
    if (existingTrack) throw new ConflictException('Track already exists in playlist');

    // Ajoute le track Ã  la playlist
    const playlistTrack = this.playlistTrackRepository.create({
      playlistId,
      trackId,
      addedById: userId,
      position,
    });
    await this.playlistTrackRepository.save(playlistTrack);
  }
}